/**
 * A very simple polyphonic MIDI synthesizer based on the Teensy
 * microcontroller with the Teensy Audio Board.
 * 
 * Features:
 * - 8 voice polyphony
 * 
 * Limitations:
 * - Fixed waveform
 * - Fixed attack/decay/sustain/release envelope
 * - No MIDI expression (velocity, aftertouch, continuous controllers)
 * 
 * Gordon Good (velo27 [at] yahoo [dot] com)
 */

/**
 * The following block of code was generated by the Teensy
 * Audio Board Audio System Design Tool (on the web
 * at http://www.pjrc.com/teensy/gui/, or available
 * with the library). It declares all the components in
 * the audio signal chain and wires them all together.
 */

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

// GUItool: begin automatically generated code
AudioSynthWaveform       waveform3;      //xy=164,214
AudioSynthWaveform       waveform4;      //xy=164,249
AudioSynthWaveform       waveform5;      //xy=164,284
AudioSynthWaveform       waveform6;      //xy=164,319
AudioSynthWaveform       waveform7;      //xy=164,354
AudioSynthWaveform       waveform8;      //xy=164,391
AudioSynthWaveform       waveform2;      //xy=165,177
AudioSynthWaveform       waveform1;      //xy=166,140
AudioEffectEnvelope      envelope7;      //xy=343,363
AudioEffectEnvelope      envelope6;      //xy=347,327
AudioEffectEnvelope      envelope1;      //xy=348,140
AudioEffectEnvelope      envelope5;      //xy=348,292
AudioEffectEnvelope      envelope8;      //xy=348,400
AudioEffectEnvelope      envelope2;      //xy=349,177
AudioEffectEnvelope      envelope4;      //xy=349,254
AudioEffectEnvelope      envelope3;      //xy=350,216
AudioMixer4              mixer1;         //xy=552,209
AudioMixer4              mixer2;         //xy=558,320
AudioMixer4              mixer3;         //xy=724,255
AudioOutputI2S           i2s1;           //xy=871,267
AudioConnection          patchCord1(waveform3, envelope3);
AudioConnection          patchCord2(waveform4, envelope4);
AudioConnection          patchCord3(waveform5, envelope5);
AudioConnection          patchCord4(waveform6, envelope6);
AudioConnection          patchCord5(waveform7, envelope7);
AudioConnection          patchCord6(waveform8, envelope8);
AudioConnection          patchCord7(waveform2, envelope2);
AudioConnection          patchCord8(waveform1, envelope1);
AudioConnection          patchCord9(envelope7, 0, mixer2, 2);
AudioConnection          patchCord10(envelope6, 0, mixer2, 1);
AudioConnection          patchCord11(envelope1, 0, mixer1, 0);
AudioConnection          patchCord12(envelope5, 0, mixer2, 0);
AudioConnection          patchCord13(envelope8, 0, mixer2, 3);
AudioConnection          patchCord14(envelope2, 0, mixer1, 1);
AudioConnection          patchCord15(envelope4, 0, mixer1, 3);
AudioConnection          patchCord16(envelope3, 0, mixer1, 2);
AudioConnection          patchCord17(mixer1, 0, mixer3, 0);
AudioConnection          patchCord18(mixer2, 0, mixer3, 1);
AudioConnection          patchCord19(mixer3, 0, i2s1, 0);
AudioConnection          patchCord20(mixer3, 0, i2s1, 1);
AudioControlSGTL5000     sgtl5000_1;     //xy=745,385
// GUItool: end automatically generated code

/**
 * End generated code block
 */


#define POLYPHONY 8  // Max # simultaneous notes
#define WAVEFORM WAVEFORM_SAWTOOTH

byte notesSounding[POLYPHONY] = {0};

// An array of pointers to all the waveform generators
AudioSynthWaveform *waveforms[POLYPHONY] = {
  &waveform1,
  &waveform2,
  &waveform3,
  &waveform4,
  &waveform5,
  &waveform6,
  &waveform7,
  &waveform8
};

// An array of pointers to all the envelope generators
AudioEffectEnvelope *envelopes[POLYPHONY] = {
  &envelope1,
  &envelope2,
  &envelope3,
  &envelope4,
  &envelope5,
  &envelope6,
  &envelope7,
  &envelope8
};

int ledPin = 13;  // LED turns on when a note is sounding
byte currentNote = 0;  // The currently sounding note

// Convert MIDI note to frequency. Algorithm borrowed from internet.
double noteToFrequency(byte note) {
  // freq = 440 * 2^((n-58) / 12)
  return 440.0 * pow(2, ((note - 58) / 12.0));
}

// Find an available waveform. If all the waveforms are
// busy, we choose one and turn it off. The caller is
// guaranteed that the returned waveform is not sounding
// Returns the index of the waveform.
byte getFreeWaveform() {
  for (byte i = 0; i < POLYPHONY; i++) {
    if (notesSounding[i] == 0) {
      return i;
    }
  }
  return 0;  // TODO(ggood) evict "oldest" sounding note instead of slot 0
}

// Turn on the LED if any notes are sounding
void updateLED() {
  for (byte i = 0; i < POLYPHONY; i++) {
    if (notesSounding[i] != 0) {
      digitalWrite(ledPin, HIGH);
      return;
    }
  }
  digitalWrite(ledPin, LOW);
}

// Handler for note on events.
void onNoteOn(byte channel, byte note, byte velocity) {
  byte index = getFreeWaveform();
  AudioSynthWaveform *waveform = waveforms[index];
  // Set the frequency of the waveform generator
  waveform->frequency(noteToFrequency(note));
  AudioEffectEnvelope *envelope = envelopes[index];
  // Turn on the nte
  envelope->noteOn();
  // Save the MIDI note number of this
  notesSounding[index] = note;
  updateLED();
}

// Handler for note off events.
void onNoteOff(byte channel, byte note, byte velocity) {
  // Figure out which index is handling the sounding note
  for (byte i = 0; i < POLYPHONY; i++) {
    if (notesSounding[i] == note) {
      AudioEffectEnvelope *envelope = envelopes[i];
      // Turn off the note
      envelope->noteOff();
      notesSounding[i] = 0;  // Free slot
    }
  }
  updateLED();
}

void setup() {
  AudioMemory(20);

  sgtl5000_1.enable();
  sgtl5000_1.volume(0.5);

  // Initialize the waveform and envelope generators
  for (byte i = 0; i < POLYPHONY; i++) {
    waveforms[i]->amplitude(0.5);
    waveforms[i]->begin(WAVEFORM);
    envelopes[i]->delay(0.0);
    envelopes[i]->hold(0.0);
  }

  // LED is on whenever a note is sounding
  pinMode(ledPin, OUTPUT);
  // Register MIDI handlers
  usbMIDI.setHandleNoteOn(onNoteOn);
  usbMIDI.setHandleNoteOff(onNoteOff);
}

void loop() {
  usbMIDI.read();
}
